<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        
        //拷贝继承：把一个对象中的属性或者方法直接复制到(通过循环遍历的方式)另一个对象中
        var obj1={
            name:'小明',
            age:15,
            eat:function(){
                console.log('吃')
            }
        }
        var obj2=obj1;  //堆里面只有一块空间，因为只是改变了指向，浅拷贝


        function Person(){

        }
        Person.prototype.age=10;
        Person.prototype.sex='男';
        Person.prototype.height=100;
        Person.prototype.play=function(){
            console.log('玩');
        };
        var obj3={};

        //Person的构造中有原型prototype，prototype就是一个对象，那么里面age,sex,height,play都是该对象中的属性或者方法

        for(var key in Person.prototype){
            obj3[key]=Person.prototype[key];    //堆里面有两块空间，一个是Person,一个是obj3,只不过是把Person堆里面的属性和方法复制了一份到obj3的堆中，是两块空间，各自的地址指向各自
        }
        console.dir(obj3);
        obj3.play();
        obj3.age=20;
        console.dir(obj3);
        console.dir(Person);


        //总结继承：
        /*
        面向对象特性：封装，继承，多态

        继承,类与类之间的关系，面向独享的语言的继承是为了多态服务的，js不是面向对象的语言，但是可以模拟面向对象，模拟继承，为了节省内存空间


        原型作用：数据共享  ，目的：为了节省内存空间
        原型作用：继承    ，目的：为了节省内存空间


        原型继承：改变原型的指向
        借用构造函数继承：主要解决属性的问题
        组合继承：原型继承+借用构造函数继承
        //既能解决属性问题，又能解决方法问题
        拷贝继承：就是把对象中需要共享的属性或者方法，直接遍历的方式复制到另一个对象中


        //===================================day4
        总结：
        //实现继承的几种方式：
        //1）通过原型实现继承(改变原型指向)，属性在初始化的时候就已经固定了，如果是多个对象实例化，那么每个实例对象的属性的值在初始化的时候都是一样的；
        //2）借用构造函数实现继承，不能继承方法
        //3）组合继承：原型继承(属性和方法)+借用构造函数继承(属性)，可以解决属性和方法的继承问题
        //3）拷贝继承：就是把一个对象中的原型中的索引的属性和方法复制一份给另一个对象
        
        
        
        
        
        
        
        
        
        
        
        */









    </script>
</body>
</html>